from fastapi import FastAPI, Response, status, HTTPException
from fastapi.params import Body
from pydantic import BaseModel
from typing import Optional
from random import randrange
import time

import psycopg2
from psycopg2.extras import RealDictCursor

import models
from database import engine, SessionLocal

models.Base.metadata.create_all(bind=engine)

# What does this do
app = FastAPI()

def get_db():
    db = SessionLocal()
    try: 
        yield db
    finally:
        db.close()

"""
See HTTP methods here: https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods

Autogenerated documentation available here: localhost:8000/docs
or available here: localhost:8000/redoc

# Run this with uvicorn app.main:app --reload
# Reload flag monitors code so that server doesn't need to be killed and restarted
# Every single time there's a change. Wouldn't use in a production environment

"""



# Create temporary memory store to serve as database in lieu of actual database for now
my_posts = [
    {"title": "title of post 1", "content": "content of post 1", "id": 1},
    {"title": "favorite food", "content": "I want bubble tea", "id": 2}
    ]

while True:
    try:
        # None of this hardcoded stuff would normally be here
        conn = psycopg2.connect(host='localhost', database='fastapi', \
            user='postgres', password='Bentley23804!', cursor_factory=RealDictCursor)
        cursor = conn.cursor()
        print("Database connection successful")
        break
    except Exception as error:
        print("Connection to database failed")
        print("Error: ", error)

    time.sleep(2) # Wait a little after an error

def find_post(id):
    for post in my_posts:
        if post['id'] == id:
            return post
        

# Use pydantic for this
class Post(BaseModel):
    # define post class to validate schema of input data
    title: str
    content: str
    published: bool = False # optional value with default setting
    # rating: Optional[int] = None # Totally optional with default none

# Decorator for a path operation
# Adds magic to actually use the API
# use HTTP 'get' request to API
# Path is 'root' here given by '/' which is basically just saying that our request goes to 
# "www.website.com/" or in our case "localhost:8000/" instead of "localhost:8000/some/other/path"
# Can make the input "/login" if we want the user to go to "localhost:8000/login"
@app.get('/')
# Write an asynchronous function (runs in some other amount of time or something)
# With an arbitrary name; async is optional here
async def root():
    # Return a python dictionary 
    # Fast API converst to JSON and sends to user (viewable on web browser)
    #return {"message": "Hello World"}
    # After making this change our server needs to be restarted
    return {"message": "Welcome to my API!"}

# Note- the FastAPI will only look at the first instance of any kind of request so 
# if we just passed '/' into the get request this function wouldn't be called
@app.get('/posts')
# write a function to get some posts
def get_posts():
    cursor.execute("""SELECT * FROM "Posts" """)
    posts = cursor.fetchall()
    return {"data": posts}



# Create a post request
# Need a schema
# title and content string
# @app.post('/createposts')
# # Extract all fields of a post and store in dictionary named payload
# def creat_post(new_post: Post):
#     print(new_post)
#     print(new_post.dict())  # Convert pydantic model to python dictionary
#     return {"new_post" : new_post}
# UPDATED BELOW

# Status code for creation is 201
@app.post('/posts', status_code=status.HTTP_201_CREATED)
# # Extract all fields of a post and store in dictionary named payload
def creat_post(post: Post):
    # post_dict = post.dict()
    # post_dict['id'] = randrange(0, 1000)
    # my_posts.append(post_dict) # Convert pydantic model to python dictionary
    # Use %s instead of fstrings to protect against SQL injection attacks
    cursor.execute(""" INSERT INTO "Posts" (title, content, published) 
                       VALUES (%s, %s, %s)
                       RETURNING * """, 
                       (post.title, post.content, post.published) 
                    )

    new_post = cursor.fetchone()

    # Commit the changes to postgres
    conn.commit()

    return {"post" : new_post}



"""
CRUD: four main functions for an API, just a common convention

Create - usually a POST request
Read   - usually a GET request
Update - usually a PUT or PATCH request
Delete - usually a DELETE request

-----------

General convention for a given API function:
When writing function for post, use the path '/posts', making sure it's plural

Anytime you create something it will have a given id. This affects GET (only if getting a 
specific something), UPDATE, and DELETE requests since the ID needs to be provided.

e.g. for reading a given post

@app.get("posts/{id}")

"""

# get latest post
# Has to go up here bc of the "latest" keyword since {id} below doesn't know
# Be careful about path parameters
# @app.get("/posts/latest")
# def get_latest_post():
#     post = my_posts[len(my_posts)-1]
#     return {"detail": post}

# get a single post
# ID is path parameter
@app.get("/posts/{id}")
def get_post(id: int, response: Response):  # Use type to make sure datatype input is correct
    # 
    cursor.execute(""" SELECT * FROM "Posts" 
                       WHERE id = %s""", 
                       (str(id)) 
                    )

    post = cursor.fetchone()

    if not post:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
            detail=f"post with id {id} was not found")

    return {"data": post}

def find_index_of_post(id: int):
    for idx, post in enumerate(my_posts):
        if post['id'] == id:
            return idx

# Delete a post
@app.delete("/posts/{id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_post(id: int):
    # delete a post with ID: id
    # Find index of array with ID
    cursor.execute(""" DELETE FROM "Posts" 
                       WHERE id = %s
                       RETURNING * """, 
                       (str(id)) 
                    )
    deleted_post = cursor.fetchone()

    conn.commit()

    if deleted_post == None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, \
            detail=f"post with id {id} does not exist")
    
    return Response(status_code=status.HTTP_204_NO_CONTENT)


# Update post
@app.put("/posts/{id}")
def update_post(id: int, post: Post):
    # Update a post with a given ID
    
    cursor.execute(""" UPDATE "Posts" 
                       SET title = %s, content = %s, published = %s
                       WHERE id = %s
                       RETURNING * """, 
                       (post.title, post.content, post.published, id) 
                    )
    updated_post = cursor.fetchone()

    conn.commit()

    if updated_post == None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, \
            detail=f"post with id {id} does not exist")

    return {"data" : updated_post}


    


